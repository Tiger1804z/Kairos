import type { Request, Response } from "express";
import prisma from "../prisma/prisma";
import {
  generateShortFinanceSummary,
  generateSQLFromQuestion,
  askKairosFromSql,
} from "../services/aiService";
import { isSafeSQL } from "../services/sqlGuard";

// logging
import { createQueryLogService } from "../services/queryLogsService";
import { createReportService } from "../services/reportsService";
import { QueryActionType, QueryStatus, ReportType } from "../../generated/prisma/client";

export const aiDailyFinanceSummary = async (req: Request, res: Response) => {
  const t0 = Date.now();

  // ✅ businessId vient du middleware
  const businessId = (req as any).businessId as number;

  // ✅ userId vient du JWT / auth middleware
  const userId = req.user!.user_id;

  const dateStr = req.query.date?.toString();
  if (!dateStr) {
    return res.status(400).json({ error: "DATE_REQUIRED" });
  }

  const start = new Date(`${dateStr}T00:00:00.000Z`);
  const end = new Date(`${dateStr}T23:59:59.999Z`);
  if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
    return res.status(400).json({ error: "INVALID_DATE_FORMAT" });
  }

  try {
    const business = await prisma.business.findUnique({
      where: { id_business: businessId },
      select: { name: true },
    });

    if (!business) {
      return res.status(404).json({ error: "BUSINESS_NOT_FOUND" });
    }

    const txs = await prisma.transaction.findMany({
      where: {
        business_id: businessId,
        transaction_date: { gte: start, lte: end },
      },
      select: { transaction_type: true, amount: true, category: true },
    });

    let income = 0;
    let expenses = 0;
    const byCat = new Map<string, number>();

    for (const tx of txs) {
      const amount = Number(tx.amount);
      const category = tx.category ?? "uncategorized";

      if (tx.transaction_type === "income") income += amount;
      else expenses += amount;

      const signed = tx.transaction_type === "income" ? amount : -amount;
      byCat.set(category, (byCat.get(category) ?? 0) + signed);
    }

    const net = income - expenses;

    const topCategories = [...byCat.entries()]
      .map(([category, total]) => ({ category, total }))
      .sort((a, b) => Math.abs(b.total) - Math.abs(a.total))
      .slice(0, 5);

    const aiText = await generateShortFinanceSummary({
      businessName: business.name,
      periodLabel: `Jour: ${dateStr}`,
      income,
      expenses,
      net,
      topCategories,
    });

    const qlog = await createQueryLogService({
      user_id: userId,
      business_id: businessId,
      natural_query: `Daily summary ${dateStr}`,
      action_type: QueryActionType.summary,
      status: QueryStatus.success,
      model_used: "gpt-4o-mini",
      execution_time_ms: Date.now() - t0,
      executed_at: new Date(),
    });

    const report = await createReportService({
      user_id: userId,
      business_id: businessId,
      query_id: qlog.id_query,
      title: `Résumé quotidien (${dateStr})`,
      report_type: ReportType.summary,
      period_start: start,
      period_end: end,
      content: aiText,
    });

    return res.status(200).json({
      business_id: businessId,
      period: { start, end },
      totals: { income, expenses, net },
      top_categories: topCategories,
      ai_summary: aiText,
      report_id: report.id_report,
      query_id: qlog.id_query,
    });
  } catch (err: any) {
    console.error("aiDailyFinanceSummary error:", err);

    await safeLogError({
      userId,
      businessId,
      question: `Daily summary ${dateStr}`,
      t0,
      message: err?.message ?? "Unknown error",
      action_type: QueryActionType.summary,
      status: QueryStatus.error,
    });

    return res.status(500).json({ error: "SERVER_ERROR" });
  }
};

export const aiAsk = async (req: Request, res: Response) => {
  const t0 = Date.now();

  const businessId = (req as any).businessId as number;
  const userId = req.user!.user_id;

  const question = req.body.question?.toString()?.trim();
  if (!question || question.length < 3) {
    return res.status(400).json({ error: "QUESTION_REQUIRED" });
  }

  const startStr = req.body.start?.toString();
  const endStr = req.body.end?.toString();
  const { start, end, periodLabel } = parsePeriod(startStr, endStr);

  try {
    const business = await prisma.business.findUnique({
      where: { id_business: businessId },
      select: { name: true },
    });

    if (!business) {
      return res.status(404).json({ error: "BUSINESS_NOT_FOUND" });
    }

    const sql = await generateSQLFromQuestion({
      question,
      businessId,
      start,
      end,
    });

    if (!isSafeSQL(sql, businessId)) {
      // ✅ log en status "blocked" (plus propre pour ton QueryStatus enum)
      await safeLogError({
        userId,
        businessId,
        question,
        sql,
        t0,
        message: "Unsafe SQL generated by AI",
        action_type: QueryActionType.sql_select,
        status: QueryStatus.blocked,
      });

      return res.status(400).json({
        error: "UNSAFE_SQL",
        sql_preview: sql?.slice(0, 200) ?? "",
      });
    }

    const result = await prisma.$queryRawUnsafe(sql);

    const { aiText, normalized } = await askKairosFromSql({
      businessName: business.name,
      periodLabel,
      question,
      rawSqlResult: result,
      currencyLabel: "$ CAD",
    });

    const qlog = await createQueryLogService({
      user_id: userId,
      business_id: businessId,
      natural_query: question,
      action_type: QueryActionType.sql_select,
      generated_sql: sql,
      status: QueryStatus.success,
      model_used: "gpt-4o-mini",
      execution_time_ms: Date.now() - t0,
      executed_at: new Date(),
    });

    const reportContent = {
      sql,
      normalized,
      aiText,
      meta: {
        business_id: businessId,
        business_name: business.name,
        period: periodLabel,
        created_at: new Date().toISOString(),
      },
    };

    const report = await createReportService({
      user_id: userId,
      business_id: businessId,
      query_id: qlog.id_query,
      title: `Résultat SQL – ${periodLabel}`,
      report_type: ReportType.custom,
      period_start: start ?? null,
      period_end: end ?? null,
      content: JSON.stringify(reportContent, null, 2),
    });

    return res.status(200).json({
      sql,
      normalized,
      aiText,
      report_id: report.id_report,
      query_id: qlog.id_query,
      meta: {
        business_id: businessId,
        business_name: business.name,
        period: periodLabel,
        execution_time_ms: Date.now() - t0,
      },
    });
  } catch (err: any) {
    console.error("aiAsk error:", err);

    await safeLogError({
      userId,
      businessId,
      question,
      t0,
      message: err?.message ?? "Unknown error",
      action_type: QueryActionType.sql_select,
      status: QueryStatus.error,
    });

    return res.status(500).json({ error: "SERVER_ERROR" });
  }
};

const parsePeriod = (startStr?: string, endStr?: string) => {
  if (startStr && endStr) {
    const start = new Date(`${startStr}T00:00:00.000Z`);
    const end = new Date(`${endStr}T23:59:59.999Z`);

    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
      return { start: null, end: null, periodLabel: "Période non spécifiée" };
    }
    return { start, end, periodLabel: `Du ${startStr} au ${endStr}` };
  }
  return { start: null, end: null, periodLabel: "Période non spécifiée" };
};

const safeLogError = async (args: {
  userId: number;
  businessId: number;
  question: string;
  sql?: string;
  t0: number;
  message: string;
  action_type: QueryActionType;
  status: QueryStatus;
}) => {
  try {
    await createQueryLogService({
      user_id: args.userId,
      business_id: args.businessId,
      natural_query: args.question,
      action_type: args.action_type,
      generated_sql: args.sql ?? null,
      status: args.status,
      error_message: args.message,
      model_used: "gpt-4o-mini",
      execution_time_ms: Date.now() - args.t0,
      executed_at: new Date(),
    });
  } catch (e) {
    console.error("Failed to create query log (error):", e);
  }
};
